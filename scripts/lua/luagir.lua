-- generated with bundle.lua
-- GORILLA <3 SANTA CLAUS
-- 2025-09-26 06:01:20

local __modules = {}
local __modules_loaded = {}
local function require(module_name) if not __modules_loaded[module_name] then if __modules[module_name] then __modules_loaded[module_name] = __modules[module_name]() else __modules_loaded[module_name] = _G.require(module_name) end end return __modules_loaded[module_name] end

-- Module "handlers.const" from ./handlers/const.lua
__modules["handlers.const"] = function(...) local helpers = require('helpers') local Const = {} Const.__index = Const Const.new = function(xml, namespace) local new_self = setmetatable({ name = string.format('%s.%s', namespace.name, xml._attr.name), value = xml._attr.value, doc = helpers.get_docs(xml), namespace = namespace, }, { __index = Const }) if helpers.get_type(xml, namespace) == 'string' then new_self.value = string.format('"%s"', new_self.value) end return new_self end Const.toString = function(self) local name = string.gsub(self.name, '%.', '') if self.doc ~= '' then return string.format('local %s = %s --- %s', name, self.value, self.doc) else return string.format('local %s = %s', name, self.value) end end return Const end

-- Module "XmlParser" from /usr/share/lua/5.4/XmlParser.lua
__modules["XmlParser"] = function(...) local function decimalToHtmlChar(code) local num = tonumber(code) if num >= 0 and num < 256 then return string.char(num) end return "&#"..code..";" end local function hexadecimalToHtmlChar(code) local num = tonumber(code, 16) if num >= 0 and num < 256 then return string.char(num) end return "&#x"..code..";" end local XmlParser = { _XML = '^([^<]*)<(%/?)([^>]-)(%/?)>', _ATTR1 = '([%w-:_]+)%s*=%s*"(.-)"', _ATTR2 = '([%w-:_]+)%s*=%s*\'(.-)\'', _CDATA = '<%!%[CDATA%[(.-)%]%]>', _PI = '<%?(.-)%?>', _COMMENT = '<!%-%-(.-)%-%->', _TAG = '^(.-)%s.*', _LEADINGWS = '^%s+', _TRAILINGWS = '%s+$', _WS = '^%s*$', _DTD1 = '<!DOCTYPE%s+(.-)%s+(SYSTEM)%s+["\'](.-)["\']%s*(%b[])%s*>', _DTD2 = '<!DOCTYPE%s+(.-)%s+(PUBLIC)%s+["\'](.-)["\']%s+["\'](.-)["\']%s*(%b[])%s*>', _DTD3 = '<!DOCTYPE%s+(.-)%s+%[%s+.-%]>', _DTD4 = '<!DOCTYPE%s+(.-)%s+(SYSTEM)%s+["\'](.-)["\']%s*>', _DTD5 = '<!DOCTYPE%s+(.-)%s+(PUBLIC)%s+["\'](.-)["\']%s+["\'](.-)["\']%s*>', _DTD6 = '<!DOCTYPE%s+(.-)%s+(PUBLIC)%s+["\'](.-)["\']%s*>', _ATTRERR1 = '=+?%s*"[^"]*$', _ATTRERR2 = '=+?%s*\'[^\']*$', _TAGEXT = '(%/?)>', _errstr = { xmlErr = "Error Parsing XML", declErr = "Error Parsing XMLDecl", declStartErr = "XMLDecl not at start of document", declAttrErr = "Invalid XMLDecl attributes", piErr = "Error Parsing Processing Instruction", commentErr = "Error Parsing Comment", cdataErr = "Error Parsing CDATA", dtdErr = "Error Parsing DTD", endTagErr = "End Tag Attributes Invalid", unmatchedTagErr = "Unbalanced Tag", incompleteXmlErr = "Incomplete XML Document", }, _ENTITIES = { ["&lt;"] = "<", ["&gt;"] = ">", ["&amp;"] = "&", ["&quot;"] = '"', ["&apos;"] = "'", ["&#(%d+);"] = decimalToHtmlChar, ["&#x(%x+);"] = hexadecimalToHtmlChar, }, } function XmlParser.new(_handler, _options) local obj = { handler = _handler, options = _options, _stack = {} } setmetatable(obj, XmlParser) obj.__index = XmlParser return obj; end local function fexists(table, elementName) if table == nil then return false end if table[elementName] == nil then return fexists(getmetatable(table), elementName) else return true end end local function err(self, errMsg, pos) if self.options.errorHandler then self.options.errorHandler(errMsg,pos) end end local function stripWS(self, s) if self.options.stripWS then s = string.gsub(s,'^%s+','') s = string.gsub(s,'%s+$','') end return s end local function parseEntities(self, s) if self.options.expandEntities then for k,v in pairs(self._ENTITIES) do s = string.gsub(s,k,v) end end return s end local function parseTag(self, s) local tag = { name = string.gsub(s, self._TAG, '%1'), attrs = {} } local parseFunction = function (k, v) tag.attrs[k] = parseEntities(self, v) tag.attrs._ = 1 end string.gsub(s, self._ATTR1, parseFunction) string.gsub(s, self._ATTR2, parseFunction) if tag.attrs._ then tag.attrs._ = nil else tag.attrs = nil end return tag end local function parseXmlDeclaration(self, xml, f) f.match, f.endMatch, f.text = string.find(xml, self._PI, f.pos) if not f.match then err(self, self._errstr.declErr, f.pos) end if f.match ~= 1 then err(self, self._errstr.declStartErr, f.pos) end local tag = parseTag(self, f.text) if tag.attrs and tag.attrs.version == nil then err(self, self._errstr.declAttrErr, f.pos) end if fexists(self.handler, 'decl') then self.handler:decl(tag, f.match, f.endMatch) end return tag end local function parseXmlProcessingInstruction(self, xml, f) local tag = {} f.match, f.endMatch, f.text = string.find(xml, self._PI, f.pos) if not f.match then err(self, self._errstr.piErr, f.pos) end if fexists(self.handler, 'pi') then tag = parseTag(self, f.text) local pi = string.sub(f.text, string.len(tag.name)+1) if pi ~= "" then if tag.attrs then tag.attrs._text = pi else tag.attrs = { _text = pi } end end self.handler:pi(tag, f.match, f.endMatch) end return tag end local function parseComment(self, xml, f) f.match, f.endMatch, f.text = string.find(xml, self._COMMENT, f.pos) if not f.match then err(self, self._errstr.commentErr, f.pos) end if fexists(self.handler, 'comment') then f.text = parseEntities(self, stripWS(self, f.text)) self.handler:comment(f.text, next, f.match, f.endMatch) end end local function _parseDtd(self, xml, pos) local dtdPatterns = {self._DTD1, self._DTD2, self._DTD3, self._DTD4, self._DTD5, self._DTD6} for _, dtd in pairs(dtdPatterns) do local m,e,r,t,n,u,i = string.find(xml, dtd, pos) if m then return m, e, {_root=r, _type=t, _name=n, _uri=u, _internal=i} end end return nil end local function parseDtd(self, xml, f) f.match, f.endMatch, _ = _parseDtd(self, xml, f.pos) if not f.match then err(self, self._errstr.dtdErr, f.pos) end if fexists(self.handler, 'dtd') then local tag = {name="DOCTYPE", value=string.sub(xml, f.match+10, f.endMatch-1)} self.handler:dtd(tag, f.match, f.endMatch) end end local function parseCdata(self, xml, f) f.match, f.endMatch, f.text = string.find(xml, self._CDATA, f.pos) if not f.match then err(self, self._errstr.cdataErr, f.pos) end if fexists(self.handler, 'cdata') then self.handler:cdata(f.text, nil, f.match, f.endMatch) end end local function parseNormalTag(self, xml, f) while 1 do f.errStart, f.errEnd = string.find(f.tagstr, self._ATTRERR1) if f.errEnd == nil then f.errStart, f.errEnd = string.find(f.tagstr, self._ATTRERR2) if f.errEnd == nil then break end end f.extStart, f.extEnd, f.endt2 = string.find(xml, self._TAGEXT, f.endMatch+1) f.tagstr = f.tagstr .. string.sub(xml, f.endMatch, f.extEnd-1) if not f.match then err(self, self._errstr.xmlErr, f.pos) end f.endMatch = f.extEnd end local tag = parseTag(self, f.tagstr) if (f.endt1=="/") then if fexists(self.handler, 'endtag') then if tag.attrs then err(self, string.format("%s (/%s)", self._errstr.endTagErr, tag.name), f.pos) end if table.remove(self._stack) ~= tag.name then err(self, string.format("%s (/%s)", self._errstr.unmatchedTagErr, tag.name), f.pos) end self.handler:endtag(tag, f.match, f.endMatch) end else table.insert(self._stack, tag.name) if fexists(self.handler, 'starttag') then self.handler:starttag(tag, f.match, f.endMatch) end if (f.endt2=="/") then table.remove(self._stack) if fexists(self.handler, 'endtag') then self.handler:endtag(tag, f.match, f.endMatch) end end end return tag end local function parseTagType(self, xml, f) if string.find(string.sub(f.tagstr, 1, 5), "?xml%s") then parseXmlDeclaration(self, xml, f) elseif string.sub(f.tagstr, 1, 1) == "?" then parseXmlProcessingInstruction(self, xml, f) elseif string.sub(f.tagstr, 1, 3) == "!--" then parseComment(self, xml, f) elseif string.sub(f.tagstr, 1, 8) == "!DOCTYPE" then parseDtd(self, xml, f) elseif string.sub(f.tagstr, 1, 8) == "![CDATA[" then parseCdata(self, xml, f) else parseNormalTag(self, xml, f) end end local function getNextTag(self, xml, f) f.match, f.endMatch, f.text, f.endt1, f.tagstr, f.endt2 = string.find(xml, self._XML, f.pos) if not f.match then if string.find(xml, self._WS, f.pos) then if #self._stack ~= 0 then err(self, self._errstr.incompleteXmlErr, f.pos) else return false end else err(self, self._errstr.xmlErr, f.pos) end end f.text = f.text or '' f.tagstr = f.tagstr or '' f.match = f.match or 0 return f.endMatch ~= nil end function XmlParser:parse(xml, parseAttributes) if type(self) ~= "table" or getmetatable(self) ~= XmlParser then error("You must call xmlparser:parse(parameters) instead of xmlparser.parse(parameters)") end if parseAttributes == nil then parseAttributes = true end self.handler.parseAttributes = parseAttributes local f = { match = 0, endMatch = 0, pos = 1, } while f.match do if not getNextTag(self, xml, f) then break end f.startText = f.match f.endText = f.match + string.len(f.text) - 1 f.match = f.match + string.len(f.text) f.text = parseEntities(self, stripWS(self, f.text)) if f.text ~= "" and fexists(self.handler, 'text') then self.handler:text(f.text, nil, f.match, f.endText) end parseTagType(self, xml, f) f.pos = f.endMatch + 1 end end XmlParser.__index = XmlParser return XmlParser end

-- Module "xmlhandler.tree" from /usr/share/lua/5.4/xmlhandler/tree.lua
__modules["xmlhandler.tree"] = function(...) local function init() local obj = { root = {}, options = {noreduce = {}} } obj._stack = {obj.root} return obj end local tree = init() function tree:new() local obj = init() obj.__index = self setmetatable(obj, self) return obj end function tree:reduce(node, key, parent) for k,v in pairs(node) do if type(v) == 'table' then self:reduce(v,k,node) end end if #node == 1 and not self.options.noreduce[key] and node._attr == nil then parent[key] = node[1] end end local function convertObjectToArray(obj) if #obj == 0 then local array = {} table.insert(array, obj) return array end return obj end function tree:starttag(tag) local node = {} if self.parseAttributes == true then node._attr=tag.attrs end local current = self._stack[#self._stack] if current[tag.name] then local array = convertObjectToArray(current[tag.name]) table.insert(array, node) current[tag.name] = array else current[tag.name] = {node} end table.insert(self._stack, node) end function tree:endtag(tag, s) local prev = self._stack[#self._stack-1] if not prev[tag.name] then error("XML Error - Unmatched Tag ["..s..":"..tag.name.."]\n") end if prev == self.root then self:reduce(prev, nil, nil) end table.remove(self._stack) end function tree:text(text) local current = self._stack[#self._stack] table.insert(current, text) end tree.cdata = tree.text tree.__index = tree return tree end

-- Module "handlers.class" from ./handlers/class.lua
__modules["handlers.class"] = function(...) local helpers = require('helpers') local Class = {} Class.__index = Class Class.new = function(xml, namespace) local new_self = setmetatable({}, { __index = Class }) new_self.namespace = namespace new_self.name = string.format('%s.%s', namespace.name, xml._attr.name) new_self.doc = helpers.get_docs(xml) new_self.parent = helpers.get_class_parents(xml, namespace) new_self.methods = helpers.get_class_methods(xml, namespace) new_self.properties = helpers.get_class_props(xml, namespace) new_self.signals = helpers.get_class_signals(xml, namespace) new_self.ctor_args = {} for _, value in pairs(new_self.properties) do if value.in_constructor or value.writable then table.insert(new_self.ctor_args, { value.name, value.value_type }) end end return new_self end Class.toString = function(self) local lines = {} local class_name = string.gsub(self.name, '%.', '') local ctor_name = string.format('%sConstructor', class_name) local formatted = {} for _, value in ipairs(self.ctor_args) do local k, v = table.unpack(value) table.insert(formatted, string.format('%s: (%s)', k, v)) end local ctors = {} if #self.parent > 0 then for _, value in ipairs(self.parent) do table.insert(ctors, string.format('%sConstructor', string.gsub(value, '%.', ''))) end end local fmt = '---@alias %s { %s }' .. (#ctors > 0 and ' | %s' or '') table.insert( lines, string.format(fmt, ctor_name, table.concat(formatted, ', '), table.concat(ctors, ' | ')) ) table.insert(lines, '') if #self.doc > 0 and not DISABLE_COMMENTS then table.insert(lines, string.format('---%s', self.doc)) end if #self.parent > 0 then table.insert( lines, string.format('---@class %s: %s', self.name, table.concat(self.parent, ', ')) ) else table.insert(lines, string.format('---@class %s', self.name)) end table.insert(lines, '---@field protected priv table') table.insert(lines, '---@field _attribute table') table.insert(lines, '---@field _property table') table.insert(lines, '---@field _gtype GObject.GType') table.insert(lines, string.format('---@field _name "%s"', self.name)) table.insert(lines, string.format('---@field derive fun(_, subclass: string): %s', self.name)) for _, v in ipairs(self.properties) do table.insert(lines, v:toString()) end for _, v in ipairs(self.signals) do table.insert(v.parameters, 1, { 'self', self.name }) table.insert(lines, v:toString()) end table.insert(lines, string.format('---@overload fun(args: %s ): %s', ctor_name, self.name)) table.insert(lines, string.format('local %s = {}', class_name)) for _, v in ipairs(self.methods) do table.insert(lines, v:toStringAsFunction(class_name)) end return table.concat(lines, '\n') end return Class end

-- Module "handlers.prop" from ./handlers/prop.lua
__modules["handlers.prop"] = function(...) local helpers = require('helpers') local Property = {} Property.__index = Property Property.new = function(xml, namespace) local new_self = setmetatable({}, { __index = Property }) new_self.name = string.gsub(xml._attr.name, '%-', '_') new_self.in_constructor = xml._attr.construct == '1' new_self.writable = xml._attr.writable == '1' new_self.value_type = helpers.get_type(xml, namespace) new_self.doc = helpers.get_docs(xml) return new_self end Property.toString = function(self) if self.writable then return string.format('---@field %s %s r/w %s', self.name, self.value_type, self.doc) else return string.format('---@field %s %s r %s', self.name, self.value_type, self.doc) end end return Property end

-- Module "helpers" from ./helpers/init.lua
__modules["helpers"] = function(...) local h = {} h.get_method_params = function(xml, namespace) local tbl = {} local param = xml.parameters if param and param['instance-parameter'] then table.insert(tbl, { 'self', '' }) end if param and param.parameter then local params = param.parameter if params.type then params = { params } end for _, value in ipairs(params) do local name, type_name = value._attr.name, h.get_type(value, namespace) if value._attr.nullable == '1' then name = ('%s?'):format(name) end if name == 'user_data' then table.insert(tbl, { '...', type_name }) elseif type_name == 'Gio.AsyncReadyCallback' then table.insert( tbl, { name, 'fun(source_object: GObject.Object, task: Gio.AsyncResult): any' } ) elseif type_name == 'Gio.DBusSignalCallback' then table.insert(tbl, { name, 'fun(connection: Gio.DBusConnection, sender_name?:, object_path: string, interface_name: string, signal_name: string, parameters: GLib.Variant, ...: any)', }) else table.insert(tbl, { name, type_name }) end end end return tbl end h.get_docs = function(xml) if xml and xml.doc and not DISABLE_COMMENTS then return string.gsub(xml.doc[1], '%s+', ' ') else return '' end end h.get_type = function(xml, namespace) if not xml then return 'nil' end if xml.array then return ('%s[]'):format(h.get_type(xml.array, namespace)) elseif xml.type then if xml.type.type then return #xml.type.type > 0 and ('table<%s, %s>'):format( h.get_type({ type = xml.type.type[1] }, namespace), h.get_type({ type = xml.type.type[2] }, namespace) ) or ('%s[]'):format(h.get_type(xml.type, namespace)) end local attr_name = xml.type._attr and xml.type._attr.name if attr_name then local full_name = string.format('%s.%s', namespace.name, attr_name) local bfield = namespace.bitfields[full_name] if bfield then local possible_values = { bfield.name } for _, value in ipairs(bfield.members) do table.insert(possible_values, string.format('"%s"', value[1])) end table.insert( possible_values, string.format('table<integer, %s>', table.concat(possible_values, ' | ')) ) return table.concat(possible_values, ' | ') end local lua_type = LGI_TO_LUA_TYPE[attr_name] return lua_type or (string.find(attr_name, '%.') and attr_name) or string.format('%s.%s', namespace.name, attr_name) end end return 'nil' end h.get_class_parents = function(xml, namespace) local parents = {} if xml._attr.parent then table.insert(parents, xml._attr.parent) end if xml.implements then for _, value in ipairs(xml.implements) do table.insert(parents, value._attr.name) end end for index, value in ipairs(parents) do if not string.find(value, '%.') then parents[index] = string.format('%s.%s', namespace.name, value) end end return parents end h.get_class_methods = function(xml, namespace) local Method = require('handlers.method') local m = {} local method_return_value = {} for _, key in ipairs { 'method', 'constructor', 'function' } do if xml and xml[key] then if xml[key]._attr then xml[key] = { xml[key] } end for _, value in ipairs(xml[key]) do local method = Method.new(value, namespace) table.insert(m, method) if string.find(method.name, '_async$') then local meth = h.transform_method_async(Method.new(value, namespace)) local method_name = string.gsub(method.name, '_async', '') if method_return_value[method_name] then meth.return_value = method_return_value[method_name] end table.insert(m, meth) else method_return_value[method.name] = method.return_value end end end end return m end h.transform_method_async = function(method) method.name = string.format('async_%s', string.sub(method.name, 1, -7)) local new_params = {} for _, value in ipairs(method.parameters) do if not (value[1] == 'io_priority' or value[1] == 'cancellable?' or value[1] == 'callback?') then table.insert(new_params, value) end end method.parameters = new_params return method end h.get_class_props = function(xml, namespace) local Property = require('handlers.prop') local p = {} for _, key in ipairs { 'property', 'field' } do if xml and xml[key] then if xml[key]._attr then xml[key] = { xml[key] } end for _, value in ipairs(xml[key]) do table.insert(p, Property.new(value, namespace)) end end end return p end h.get_class_signals = function(xml, namespace) local Method = require('handlers.method') local m = {} if xml and xml['glib:signal'] and xml['glib:signal']._attr then xml['glib:signal'] = { xml['glib:signal'] } end if xml and xml['glib:signal'] then for _, value in ipairs(xml['glib:signal']) do local new_signal = Method.new(value, namespace) new_signal.name = ('on_%s'):format(new_signal.name:gsub('%-', '_')) table.insert(m, new_signal) end end return m end return h end

-- Module "xml2lua" from /usr/share/lua/5.4/xml2lua.lua
__modules["xml2lua"] = function(...) local xml2lua = { _VERSION = "1.6-1" } local XmlParser = require("XmlParser") local function printableInternal(tb, level) if tb == nil then return end level = level or 1 local spaces = string.rep(' ', level*2) for k,v in pairs(tb) do if type(v) == "table" then print(spaces .. k) printableInternal(v, level+1) else print(spaces .. k..'='..v) end end end function xml2lua.parser(handler) if handler == xml2lua then error("You must call xml2lua.parse(handler) instead of xml2lua:parse(handler)") end local options = { stripWS = 1, expandEntities = 1, errorHandler = function(errMsg, pos) error(string.format("%s [char=%d]\n", errMsg or "Parse Error", pos)) end } return XmlParser.new(handler, options) end function xml2lua.printable(tb) printableInternal(tb) end function xml2lua.toString(t) local sep = '' local res = '' if type(t) ~= 'table' then return t end for k,v in pairs(t) do if type(v) == 'table' then v = xml2lua.toString(v) end res = res .. sep .. string.format("%s=%s", k, v) sep = ',' end res = '{'..res..'}' return res end function xml2lua.loadFile(xmlFilePath) local f, e = io.open(xmlFilePath, "r") if f then local content = f:read("*a") f:close() return content end error(e) end local function attrToXml(attrTable) local s = "" attrTable = attrTable or {} for k, v in pairs(attrTable) do s = s .. " " .. k .. "=" .. '"' .. v .. '"' end return s end local function getSingleChild(tb) local count = 0 for _ in pairs(tb) do count = count + 1 end if (count == 1) then for k, _ in pairs(tb) do return k end end return nil end local function getFirstValue(tb) if type(tb) == "table" then for _, v in pairs(tb) do return v end return nil end return tb end xml2lua.pretty = true function xml2lua.getSpaces(level) local spaces = '' if (xml2lua.pretty) then spaces = string.rep(' ', level * 2) end return spaces end function xml2lua.addTagValueAttr(tagName, tagValue, attrTable, level) local attrStr = attrToXml(attrTable) local spaces = xml2lua.getSpaces(level) if (tagValue == '') then table.insert(xml2lua.xmltb, spaces .. '<' .. tagName .. attrStr .. '/>') else table.insert(xml2lua.xmltb, spaces .. '<' .. tagName .. attrStr .. '>' .. tostring(tagValue) .. '</' .. tagName .. '>') end end function xml2lua.startTag(tagName, attrTable, level) local attrStr = attrToXml(attrTable) local spaces = xml2lua.getSpaces(level) if (tagName ~= nil) then table.insert(xml2lua.xmltb, spaces .. '<' .. tagName .. attrStr .. '>') end end function xml2lua.endTag(tagName, level) local spaces = xml2lua.getSpaces(level) if (tagName ~= nil) then table.insert(xml2lua.xmltb, spaces .. '</' .. tagName .. '>') end end function xml2lua.isChildArray(obj) for tag, _ in pairs(obj) do if (type(tag) == 'number') then return true end end return false end function xml2lua.isTableEmpty(obj) for k, _ in pairs(obj) do if (k ~= '_attr') then return false end end return true end function xml2lua.parseTableToXml(obj, tagName, level) if (tagName ~= '_attr') then if (type(obj) == 'table') then if (xml2lua.isChildArray(obj)) then for _, value in pairs(obj) do xml2lua.parseTableToXml(value, tagName, level) end elseif xml2lua.isTableEmpty(obj) then xml2lua.addTagValueAttr(tagName, "", obj._attr, level) else xml2lua.startTag(tagName, obj._attr, level) for tag, value in pairs(obj) do xml2lua.parseTableToXml(value, tag, level + 1) end xml2lua.endTag(tagName, level) end else xml2lua.addTagValueAttr(tagName, obj, nil, level) end end end function xml2lua.toXml(tb, tableName, level) xml2lua.xmltb = {} level = level or 0 local singleChild = getSingleChild(tb) tableName = tableName or singleChild if (singleChild) then xml2lua.parseTableToXml(getFirstValue(tb), tableName, level) else xml2lua.parseTableToXml(tb, tableName, level) end if (xml2lua.pretty) then return table.concat(xml2lua.xmltb, '\n') end return table.concat(xml2lua.xmltb) end return xml2lua end

-- Module "handlers.gir" from ./handlers/gir.lua
__modules["handlers.gir"] = function(...) local handler = require('xmlhandler.tree') local Bitfield = require('handlers.bitfields') local Class = require('handlers.class') local Const = require('handlers.const') local Enum = require('handlers.enum') local Method = require('handlers.method') local print_start = function(message) io.write(message .. '... ') io.flush() end local print_done = function() io.write('\27[32mDone\27[0m\n') io.flush() end local print_error = function() io.write('\27[31mFailed\27[0m\n') io.flush() end local gir = {} gir.__index = gir gir.loadFile = function(self, filepath) print_start('Opening file') local file = io.open(filepath, 'r') if not file then print_error() return nil end local content = file:read('a') file:close() print_done() return content end gir.loadXML = function(self, str) print_start('Reading XML') local new_handler = handler:new() local xml2lua = require('xml2lua') local parser = xml2lua.parser(new_handler) parser:parse(str) print_done() return new_handler.root end gir.addClass = function(self, xml) local class = Class.new(xml, self) self.classes[class.name] = class end gir.addConst = function(self, xml) local const = Const.new(xml, self) self.consts[const.name] = const end gir.addBitfield = function(self, xml) local bfield = Bitfield.new(xml, self) self.bitfields[bfield.name] = bfield end gir.addEnum = function(self, xml) local enum = Enum.new(xml, self) self.enumerations[enum.name] = enum end gir.addFunc = function(self, xml) local fun = Method.new(xml, self) self.functions[fun.name] = fun end gir.saveToFile = function(self, path) print_start('Opening file') local file = io.open(path, 'w') if not file then print_error() return false end print_done() local content = self:toString() print_start('Saving content') file:write(content) file:close() print_done() return true end gir.toString = function(self) print_start('Generating types') local lines = { '---@meta _', '' } for _, value in ipairs { self.consts, self.bitfields, self.enumerations, self.classes } do for _, v in pairs(value) do table.insert(lines, v:toString()) table.insert(lines, '') end end table.insert(lines, '') table.insert(lines, string.format('---@class %s', self.name)) for _, value in pairs(self.classes) do table.insert( lines, string.format('---@field %s %s', string.gsub(value.name, '^[^.]+%.', ''), value.name) ) end for _, value in pairs(self.functions) do table.insert(lines, value:toString()) end table.insert(lines, string.format('local %s = {', self.name)) for _, value in ipairs { self.enumerations, self.bitfields, self.consts } do for _, v in pairs(value) do local k, _v = string.gsub(v.name, '^[^.]+%.', ''), string.gsub(v.name, '%.', '') table.insert(lines, string.format('    %s = %s,', k, _v)) end end table.insert(lines, '}') print_done() return table.concat(lines, '\n') end local len = function(tbl) local count = 0 for _ in pairs(tbl) do count = count + 1 end return count end return function(libname) local new_gir = setmetatable({ classes = {}, consts = {}, bitfields = {}, enumerations = {}, functions = {}, }, { __index = gir }) new_gir.name, new_gir.version = string.match(libname, '^(.-)%-(.+)$') local content = new_gir:loadFile(string.format('%s/%s.gir', GIR_PATH, libname)) if not content then return end local xml = new_gir:loadXML(content) if not xml then return end new_gir.xml = xml print_start(string.format('Parsing %s', libname)) for _, element in ipairs { { key = 'bitfield', method = 'addBitfield' }, { key = 'constant', method = 'addConst' }, { key = 'enumeration', method = 'addEnum' }, { key = 'class', method = 'addClass' }, { key = 'interface', method = 'addClass' }, { key = 'record', method = 'addClass' }, { key = 'function', method = 'addFunc' }, } do local data = new_gir.xml.repository.namespace[element.key] if data and data._attr and data._attr.name then data = { data } end if data and #data > 0 then for _, value in ipairs(data) do new_gir[element.method](new_gir, value) end end end print_done() print(string.format('  | %d Classes', len(new_gir.classes))) print(string.format('  | %d Constants', len(new_gir.consts))) print(string.format('  | %d Bitfields', len(new_gir.bitfields))) print(string.format('  | %d Enumerations', len(new_gir.enumerations))) print(string.format('  | %d Functions', len(new_gir.functions))) return new_gir end end

-- Module "handlers.enum" from ./handlers/enum.lua
__modules["handlers.enum"] = function(...) local Enumeration = {} Enumeration.__index = Enumeration Enumeration.new = function(xml, namespace) local new_self = setmetatable( { name = string.format('%s.%s', namespace.name, xml._attr.name), members = {} }, { __index = Enumeration } ) for _, mmber in ipairs(xml.member) do table.insert(new_self.members, { string.upper(mmber._attr.name), mmber._attr.value }) end return new_self end Enumeration.toString = function(self) local lines = {} table.insert(lines, string.format('---@enum (key) %s', self.name)) table.insert(lines, string.format('local %s = {', string.gsub(self.name, '%.', ''))) for _, member in ipairs(self.members) do local key, value = table.unpack(member) table.insert(lines, string.format('   %s = %s,', key, value)) end table.insert(lines, '}') return table.concat(lines, '\n') end return Enumeration end

-- Module "handlers.bitfields" from ./handlers/bitfields.lua
__modules["handlers.bitfields"] = function(...) local helpers = require('helpers') local Bitfield = {} Bitfield.__index = Bitfield Bitfield.new = function(xml, namespace) local new_self = setmetatable({}, { __index = Bitfield }) new_self.name = string.format('%s.%s', namespace.name, xml._attr.name) new_self.members = {} if xml.member and xml.member._attr and xml.member._attr.name then xml.member = { xml.member } end for _, member in pairs(xml.member) do table.insert( new_self.members, { string.upper(member._attr.name), member._attr.value, helpers.get_docs(member) } ) end return new_self end Bitfield.toString = function(self) local lines = {} table.insert(lines, string.format('---@enum %s', self.name)) table.insert(lines, string.format('local %s = {', string.gsub(self.name, '%.', ''))) for _, value in ipairs(self.members) do if value[3] ~= '' then table.insert(lines, string.format('    ---%s', value[3])) end table.insert(lines, string.format('    %s = %s,', value[1], value[2])) end table.insert(lines, '}') return table.concat(lines, '\n') end return Bitfield end

-- Module "handlers.method" from ./handlers/method.lua
__modules["handlers.method"] = function(...) local helpers = require('helpers') local Method = {} Method.__index = Method Method.toString = function(self) local params = {} for _, value in ipairs(self.parameters) do local k, v = table.unpack(value) if k == 'self' then table.insert(params, 'self') else table.insert(params, string.format('%s: %s', k, v)) end end return ('---@field %s fun(%s): %s %s'):format( self.name, table.concat(params, ', '), self.return_value, self.doc ) end Method.toStringAsFunction = function(self, class_name) local lines, params = {}, {} local is_static = true if #self.doc > 0 and not DISABLE_COMMENTS then table.insert(lines, '') table.insert(lines, '---' .. self.doc) end if #self.doc == 0 and #self.parameters > 1 then table.insert(lines, '') end for _, value in ipairs(self.parameters) do local k, v, doc = table.unpack(value) if k == 'self' then is_static = false else table.insert( lines, string.format('---@param %s %s %s', k, v, DISABLE_COMMENTS and doc or '') ) k = string.gsub(k, '%?', '') table.insert(params, k) end end table.insert( lines, string.format('---@return %s #%s', self.return_value, self.return_value_doc) ) if self.is_async then table.insert(lines, '---@async') end local fmt = is_static and 'function %s.%s(%s) end' or 'function %s:%s(%s) end' table.insert(lines, string.format(fmt, class_name, self.name, table.concat(params, ', '))) return table.concat(lines, '\n') end Method.new = function(xml, namespace) local new_self = setmetatable({ namespace = namespace }, { __index = Method }) new_self.name = xml._attr.name new_self.doc = helpers.get_docs(xml) new_self.parameters = helpers.get_method_params(xml, new_self.namespace) new_self.return_value = helpers.get_type(xml['return-value'], new_self.namespace) new_self.return_value_doc = helpers.get_docs(xml['return-value']) new_self.is_async = false if xml.parameters and xml.parameters.parameter then if xml.parameters.parameter._attr then xml.parameters.parameter = { xml.parameters.parameter } end for _, value in ipairs(xml.parameters.parameter) do if value._attr.scope == 'async' then new_self.is_async = true break end end end return new_self end return Method end

-- Entry file "init.lua"
do if not os.getenv('LUAGIR_PATH') then CACHE_PATH = os.getenv('HOME') .. '/.cache/luagir' else CACHE_PATH = os.getenv('LUAGIR_PATH') end DISABLE_COMMENTS = false GIR_PATH = '/usr/share/gir-1.0' LGI_TO_LUA_TYPE = { gboolean = 'boolean', gint = 'number', guint = 'number', gint8 = 'number', guint8 = 'number', gint16 = 'number', guint16 = 'number', gint32 = 'number', guint32 = 'number', gint64 = 'number', guint64 = 'number', none = 'nil', gchar = 'string', guchar = 'string', ['gchar*'] = 'string', ['guchar*'] = 'string', glong = 'number', gulong = 'number', glong64 = 'number', gulong64 = 'number', gfloat = 'number', gdouble = 'number', gsize = 'number', string = 'string', GString = 'string', utf8 = 'string', gpointer = 'any', filename = 'string', ['GObject.Callback'] = 'function', } os.execute(string.format('mkdir -p %s', CACHE_PATH)) local load_gir = require('handlers.gir') local is_valid_flag = function(arg) return arg == '-h' or arg == '--help' or arg == '--no-comments' end for i, arg_value in ipairs(arg) do if arg_value == '-h' or arg_value == '--help' then print(table.concat({ 'Usage: lua init.lua [options] <Library-1> <Library-2> ...', '', 'Options:', '  -h, --help         Show this help message and exit.', '  --no-comments      Disable comments in the generated Lua files.', '', 'Examples:', '  lua init.lua Gtk-3.0 GLib-2.0 GObject-2.0', '  lua init.lua --no-comments Gtk-3.0', }, '\n')) os.exit(0) end if arg_value == '--no-comments' then DISABLE_COMMENTS = true table.remove(arg, i) end end local filtered_args = {} for _, arg_value in ipairs(arg) do if not is_valid_flag(arg_value) then table.insert(filtered_args, arg_value) end end if #filtered_args == 0 then print('Usage: lua init.lua <Library-1> <Library-2> ...') print('Example: lua init.lua Gtk-3.0 GLib-2.0 GObject-2.0') os.exit(1) end for _, lib in ipairs(filtered_args) do print('') local gir = load_gir(lib) if gir then gir:saveToFile(('%s/%s.lua'):format(CACHE_PATH, lib)) else print(('\27[31m%s not found.\27[0m'):format(lib)) end print('') end end
